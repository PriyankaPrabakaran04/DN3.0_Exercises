Understanding Sorting Algorithms
Bubble Sort:

Description: A simple comparison-based sorting algorithm where each pair of adjacent elements is compared, and the elements are swapped if they are in the wrong order. This process is repeated until the array is sorted.
Time Complexity:
Best-case: 
O(n) (when the array is already sorted)
Average-case: 
ğ‘‚(ğ‘›^2)
Worst-case: 
ğ‘‚(ğ‘›^2)
Insertion Sort:

Description: Builds the final sorted array one item at a time. It picks an element from the unsorted part and places it at the correct position in the sorted part.
Time Complexity:
Best-case: 
O(n) (when the array is already sorted)
Average-case: 
ğ‘‚(ğ‘›^2)
Worst-case: 
O(n ^2)
Quick Sort:

Description: A divide-and-conquer algorithm that selects a 'pivot' element and partitions the array into two sub-arrays: elements less than the pivot and elements greater than the pivot. The process is recursively applied to the sub-arrays.
Time Complexity:
Best-case: 
O(nlogn)
Average-case: 
O(nlogn)
Worst-case: 
O(n^2) (when the pivot selection is poor, e.g., always picking the smallest or largest element)
Merge Sort:

Description: A divide-and-conquer algorithm that divides the array into two halves, sorts each half, and then merges the two sorted halves back together.
Time Complexity:
Best-case: 
ğ‘‚(ğ‘›log ğ‘›)
O(nlogn)
Average-case: 
ğ‘‚(ğ‘› log ğ‘›)
O(nlogn)
Worst-case: 
ğ‘‚(ğ‘›logğ‘›)
